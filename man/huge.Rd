% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/huge.R
\name{huge}
\alias{huge}
\title{High-dimensional undirected graph estimation.}
\usage{
huge(x, lambda = NULL, nlambda = NULL, lambda.min.ratio = NULL,
  method = "mb", scr = NULL, scr.num = NULL, cov.output = FALSE,
  sym = "or", verbose = TRUE)
}
\arguments{
\item{x}{There are 2 options: (1) \code{x} is an \code{n} by \code{d} data matrix (2) a \code{d} by \code{d} sample covariance matrix. The program automatically identifies the input matrix by checking the symmetry. (\code{n} is the sample size and \code{d} is the dimension).}

\item{lambda}{A sequence of decresing positive numbers to control the regularization when \code{method = "mb"} or \code{"glasso"}, or the thresholding in \code{method = "ct"}. Typical usage is to leave the input \code{lambda = NULL} and have the program compute its own \code{lambda} sequence based on \code{nlambda} and \code{lambda.min.ratio}. Users can also specify a sequence to override this. When \code{method = "mb"} or \code{"glasso"}, use with care - it is better to supply a decreasing sequence values than a single (small) value.}

\item{nlambda}{The number of regularization/thresholding paramters. The default value is \code{30} for \code{method = "ct"} and \code{10} for \code{method = "mb"} or \code{"glasso"}.}

\item{lambda.min.ratio}{If \code{method = "mb"} or \code{"glasso"}, it is the smallest value for \code{lambda}, as a fraction of the uppperbound (\code{MAX}) of the regularization/thresholding parameter which makes all estimates equal to \code{0}. The program can automatically generate \code{lambda} as a sequence of length = \code{nlambda} starting from \code{MAX} to \code{lambda.min.ratio*MAX} in log scale. If \code{method = "ct"}, it is the largest sparsity level for estimated graphs. The program can automatically generate \code{lambda} as a sequence of length = \code{nlambda}, which makes the sparsity level of the graph path increases from \code{0} to \code{lambda.min.ratio} evenly.The default value is \code{0.1} when \code{method = "mb"} or \code{"glasso"}, and 0.05 \code{method = "ct"}.}

\item{method}{Graph estimation methods with 3 options: \code{"mb"}, \code{"ct"} and \code{"glasso"}. The defaulty value is \code{"mb"}.}

\item{scr}{If \code{scr = TRUE}, the lossy screening rule is applied to preselect the neighborhood before the graph estimation. The default value is  \code{FALSE}. NOT applicable when \code{method = "ct"}.}

\item{scr.num}{The neighborhood size after the lossy screening rule (the number of remaining neighbors per node). ONLY applicable when \code{scr = TRUE}. The default value is \code{n-1}. An alternative value is \code{n/log(n)}. ONLY applicable when \code{scr = TRUE} and \code{method = "mb"}.}

\item{cov.output}{If \code{cov.output = TRUE}, the output will inlcude a path of estimated covariance matrices. ONLY applicable when \code{method = "glasso"}. Since the estimated covariance matrices are generally not sparse, please use it with care, or it may take much memory under high-dimensional setting. The default value is \code{FALSE}.}

\item{sym}{Symmetrize the output graphs. If \code{sym = "and"}, the edge between node \code{i} and node \code{j} is selected ONLY when both node \code{i} and node \code{j} are selected as neighbors for each other. If \code{sym = "or"}, the edge is selected when either node \code{i} or node \code{j} is selected as the neighbor for each other. The default value is \code{"or"}. ONLY applicable when \code{method = "mb"}.}

\item{verbose}{If \code{verbose = FALSE}, tracing information printing is disabled. The default value is \code{TRUE}.}
}
\value{
The sum of \code{x} and \code{y}.
}
\description{
High-dimensional undirected graph estimation.
}
\examples{
#generate data
L = huge.generator(n = 50, d = 12, graph = "hub", g = 4)

#graph path estimation using mb
out1 = huge(L$data)
out1
plot(out1)				 #Not aligned	
plot(out1, align = TRUE) #Aligned
huge.plot(out1$path[[3]])

#graph path estimation using the sample covariance matrix as the input.
#out1 = huge(cor(L$data))
#out1
#plot(out1)				 #Not aligned	
#plot(out1, align = TRUE) #Aligned
#huge.plot(out1$path[[3]])

#graph path estimation using ct
#out2 = huge(L$data,method = "ct")
#out2
#plot(out2)

#graph path estimation using glasso
#out3 = huge(L$data, method = "glasso")
#out3
#plot(out3)
}
